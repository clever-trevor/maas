#!/usr/bin/python3

# This routing controls viewing and running Groups of tests
import cgi
import elasticsearch
import influx
import datetime
import configparser

# Read in the config for this entity
maas = configparser.RawConfigParser()
maas.read('/app/maas/conf/env')

# Set some variables from this
influx_url = maas['influxdb']['url'] + "/query"

es = { "url": maas['elastic']['url'] ,"user": maas['elastic']['user'],"pass": maas['elastic']['pass'] }
entity_index = "maas_config_entity_publish"

# REad in parameters passed to page
fs = cgi.FieldStorage()

# Build the query for entities if provided 
entities = "*"
if 'entities' in fs :
  entities = fs['entities'].value

print("Content-Type:text/html;\n")
print("<html><head><link rel='stylesheet' type='text/css' href='/dark.css'></head>")
print("<h1><A style='text-decoration:none' HREF='/cgi-bin/index'>Agent Health</a></h1>")
print("<hr>")

# Build Elastic query to return all records which match the supplied tag
query = "q=entity:" + entities + "&_source_includes=entity"
x = elasticsearch.run_search_uri(es,entity_index, query + "&size=10000")['hits']

# If no results returned, then drop out
if x['total'] == 0:
  print("<h2>No entities found for <i>%s</i></h2>" % ( entities ))
  exit()

# Bring the records into a list and sort by entityname (nested dictionary)
records = x['hits']
records = sorted(records,key=lambda i: i['_source']['entity'])

# Test mode means to execute the tests
print("<H2>Last Reboot Measurement for Hosts</h2>")

# Build a table of each test executed to show at the end
print("<TABLE class='blueTable'><TR><TH>Hostname<TH>Last Reboot<TH>Last Measurement</TR>")

status = {}  # Dictionary used to store the overall monitors and status
for r in records :
  r = r['_source']
  entity = r['entity']
  metric_type = "system"
  metric_name = "uptime"

  # Run an Influx query for each metric
  query = "SELECT last(%s) FROM telegraf.autogen.%s WHERE host = '%s' GROUP BY entity" % ( metric_name, metric_type, entity)
  value, time_stamp = influx.get_metric(influx_url,query)

  # Work out last reboot based on uptime
  reboot = datetime.datetime.now() - datetime.timedelta(seconds=value)
  reboot = reboot.strftime("%Y-%m-%d %H:%M:%S")

  # Reformat the time stamp field
  time_stamp = time_stamp.replace("T"," ").replace("Z","")
  time_stamp = datetime.datetime.strptime(time_stamp,"%Y-%m-%d %H:%M:%S")
  metric_age = datetime.datetime.utcnow() - time_stamp
  metric_age = int(metric_age.total_seconds())
  color = "GREEN"
  if metric_age > 120 :
    color = "RED"

  print("<TR><TD>%s<TD>%s<TD><FONT COLOR='%s'><p title='%s seconds'>%s</p></FONT></TR>" % (entity,reboot,color,metric_age,time_stamp) )


print("</TABLE>")

print("</html>")
